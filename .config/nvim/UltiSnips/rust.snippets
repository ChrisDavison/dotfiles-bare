snippet display "Impl Display"
impl std::fmt::Display for ${1:Type} {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "${2}", self.${3})
	}
}
endsnippet
snippet fromstr "Impl FromStr"
impl std::str::FromStr for ${1:Type} {
	type Err = anyhow::Error;

	fn from_str(s: &str) -> Result<Self, Self::Err> {
		${2}	
		Ok(${1:Type} { ... })
	}
}
endsnippet

snippet tostring "Impl ToString"
impl ToString for ${1:Type}
	fn to_string(&self) -> String {
		${2:code...}
	}
}
endsnippet

snippet debug "Impl Debug"
impl std::fmt::Debug for ${1:TYPE} {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "${2:MESSAGE}", ${3:self.FIELDS...})
    }
}
endsnippet

snippet default "Impl Default"
impl std::default::Default for ${1:TYPE} {
	fn default() -> Self { ${1:TYPE}{} }
}
endsnippet

snippet defaulte "Impl Default for Enum"
impl std::default::Default for ${1:ENUM} {
	fn default() -> Self { ${1:ENUM}::${2:VARIANT} }
}
endsnippet

snippet iter "Impl Iter"
impl std::iter::Iterator for ${1:TYPE} {
	type Item = $1;
	fn next(&mut self) -> Option<Self::Item> {
		${2:CODE}
		while ${3:CONDITION} {
			return Some(...);
		}
		None	
	}
}
endsnippet

snippet derive "Derive"
#[derive(${1})]
endsnippet

snippet derives "Derive"
#[derive(Debug, Clone, PartialEq${1})]
endsnippet

snippet pp "Print (debug)"
println!("{:?}", $1);
endsnippet

snippet ppp "Pretty print (debug mode)"
println!("{:#?}", $1);
endsnippet

snippet cfgd "Config for debug mode"
#[cfg(debug_assertions)]
${1:code}
endsnippet
snippet cfgd! "Config macro for debug mode"
if cfg!(debug_assertions) {
	${1:code}
}
endsnippet

snippet cfgnd "Config for release mode"
#[cfg(not(debug_assertions))]
${1:code}
endsnippet
snippet cfgnd! "Config macro for release mode"
if cfg!(not(debug_assertions)) {
	${1:code}
}
endsnippet

